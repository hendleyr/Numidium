<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<style>
			#loadingScreen {
				position:absolute;
				width:100%;
				height:100%;
				background-color:#000;
				color:#fff;
				z-index:10;
			}
		
			html, body {
				width: 100%;
				height: 100%;
			}

			body {
				background-color: #ffffff;
				margin: 0;
				overflow: hidden;
				font-family: arial;
			}

			#blocker {

				position: absolute;

				width: 100%;
				height: 100%;

				background-color: rgba(0,0,0,0.5);

			}

			#instructions {

				width: 100%;
				height: 100%;

				display: -webkit-box;
				display: -moz-box;
				display: box;

				-webkit-box-orient: horizontal;
				-moz-box-orient: horizontal;
				box-orient: horizontal;

				-webkit-box-pack: center;
				-moz-box-pack: center;
				box-pack: center;

				-webkit-box-align: center;
				-moz-box-align: center;
				box-align: center;

				color: #ffffff;
				text-align: center;

				cursor: pointer;

			}
		</style>
	</head>
	<body>
		<div id="loadingScreen">Loading...</div>
		<div id="blocker">
			<div id="instructions">
				<span style="font-size:40px">Click to begin</span>
				<br />
				Keyboard:
				<br />
				W, A, S, D = Move, SPACE = Jump, MOUSE = Look, ESCAPE = Pause
				<br />
				I / O / P = Anaglyph / Oculus / Projection Views
				<br />
				M = Mute/Unmute Audio
				<br />
				<br />
				Gamepad:
				<br />
				Left stick = Move Position (Click to sprint)
				<br />
				Right stick = Look
				<br />
				Start = Refresh Page,   Select = Mute/Unmute Audio
				<br />
				D-Pad Left/Down/Right = Anaglyph / Oculus / Projection Views
			</div>
		</div>
		<script>
			//NAMESPACE
			var NUMIDIUM = {};
		</script>
		<script src="scripts/lib/three.js"></script>
		<script src="scripts/lib/Detector.js"></script>
		<script src="scripts/lib/stats.min.js"></script>
		<script src="scripts/lib/Octree.js"></script>
		<script src="scripts/effects/CopyShader.js"></script>
		<script src="scripts/effects/SSAOShader.js"></script>
		<script src="scripts/effects/EffectComposer.js"></script>
		<script src="scripts/effects/RenderPass.js"></script>
		<script src="scripts/effects/MaskPass.js"></script>		
		<script src="scripts/effects/ShaderPass.js"></script>
		<script src="scripts/loaders/OBJLoader.js"></script>
		<script src="scripts/Controls/gamepad.js"></script>
		<script src="scripts/Controls/NumidiumControls.js"></script>
		<script src="scripts/Controls/NumidiumOculusControls.js"></script>
		<script src="scripts/effects/NumidiumOculusRiftEffect.js"></script>
		<script src="scripts/effects/NumidiumAnaglyphEffect.js"></script>
		
		<script>
			var pointerLockAttach = function () {
					var blocker = document.getElementById( 'blocker' );
					//var instructions = document.getElementById( 'instructions' );

					// http://www.html5rocks.com/en/tutorials/pointerlock/intro/

					var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

					if ( havePointerLock ) {
						var element = document.body;

						var pointerlockchange = function ( event ) {
							if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {
								kbamControls.enabled = true;

								blocker.style.display = 'none';
							} else {
								kbamControls.enabled = false;

								blocker.style.display = '-webkit-box';
								blocker.style.display = '-moz-box';
								blocker.style.display = 'box';
								
								instructions.style.display = '';
							}
						}

						var pointerlockerror = function ( event ) {
							instructions.style.display = '';
						}

						// Hook pointer lock state change events
						document.addEventListener( 'pointerlockchange', pointerlockchange, false );
						document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
						document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );
						document.addEventListener( 'pointerlockerror', pointerlockerror, false );
						document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
						document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );
						
						instructions.addEventListener( 'click', function ( event ) {
						instructions.style.display = 'none';

						// Ask the browser to lock the pointer
						element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;

						if ( /Firefox/i.test( navigator.userAgent ) ) {
							var fullscreenchange = function ( event ) {
								if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {
									document.removeEventListener( 'fullscreenchange', fullscreenchange );
									document.removeEventListener( 'mozfullscreenchange', fullscreenchange );

									element.requestPointerLock();
								}
							}

							document.addEventListener( 'fullscreenchange', fullscreenchange, false );
							document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );

							element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;

							element.requestFullscreen();

						} else {
							element.requestPointerLock();
						}

					}, false );
				} else {
					instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
				}
			};
		
			// workaround for chrome bug: http://code.google.com/p/chromium/issues/detail?id=35980#c12
			if ( window.innerWidth === 0 ) { window.innerWidth = parent.innerWidth; window.innerHeight = parent.innerHeight; }

			//SCENE
			var scene, sceneGraph;
			//CAMERA
			var camera;
			//RENDER
			var renderer, anaglyphRenderer, oculusRenderer, stats;
			var	isAnaglyph = false, isOculus = false;
			//POST PROCESSING
			var depthMaterial, depthTarget, composer;
			//SKYBOX
			//GEOMETRY
			var collisionMesh
			//CONTROLS
			var kBamControls, oculusControls;
			var  time = Date.now(), clock = new THREE.Clock();

			init();
			animate();

			function initScene() {
				scene = new THREE.Scene();
				scene.fog = new THREE.FogExp2( 0x38332D, 0.00075 );
				scene.add( new THREE.AmbientLight( 0x727473 ) );
				
				var directionalLight = new THREE.DirectionalLight( 0xfefdbc, 0.5 );
				directionalLight.position.set( -1500, 1100, 1200 );
				directionalLight.shadowDarkness = 0.2;
				scene.add( directionalLight );
				
				sceneGraph = new THREE.Octree( {
					// scene: scene,
					undeferred: true,
					depthMax: Infinity,
					objectsThreshold: 128,
					overlapPct: 0.25
				} );
			};			
			function initCamera() {
				var viewAngle = 45;
				var aspectRatio = window.innerWidth / window.innerHeight;
				var nearClip = 1;
				var farClip = 10000;
				camera = new THREE.PerspectiveCamera(viewAngle, aspectRatio, nearClip, farClip);
			};			
			function initRenderer() {
				if ( Detector.webgl ) {
					renderer = new THREE.WebGLRenderer();
				}
				else {
					renderer = new THREE.CanvasRenderer();
				}
				
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
				
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.bottom = '0px';
				stats.domElement.style.zIndex = 100;
				document.body.appendChild( stats.domElement );
				
				oculusRenderer = new NUMIDIUM.OculusRiftEffect( renderer, camera, { worldFactor: 1 } );
				anaglyphRenderer = new NUMIDIUM.AnaglyphEffect( renderer, window.innerWidth, window.innerHeight );
				
				document.addEventListener( 'keydown', onKeyDown, false );
				window.addEventListener( 'resize', onWindowResize, false );
			};
			function initPostProcessing() {
				var tweakedSSAOShader = {
					uniforms: {
						"tDiffuse":     { type: "t", value: null },
						"tDepth":       { type: "t", value: null },
						"size":         { type: "v2", value: new THREE.Vector2( 512, 512 ) },
						"cameraNear":   { type: "f", value: 1 },
						"cameraFar":    { type: "f", value: 100 },
						"fogNear":      { type: "f", value: 5 },
						"fogFar":       { type: "f", value: 100 },
						"fogEnabled":   { type: "i", value: 0 },
						"onlyAO":       { type: "i", value: 0 },
						"aoClamp":      { type: "f", value: 0.3 },
						"lumInfluence": { type: "f", value: 0.9 }
					},

					vertexShader: [
						"varying vec2 vUv;",
						"void main() {",
							"vUv = uv;",
							"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
						"}"
					].join("\n"),

					fragmentShader: [
						"uniform float cameraNear;",
						"uniform float cameraFar;",
						"uniform float fogNear;",
						"uniform float fogFar;",
						"uniform bool fogEnabled;",  // attenuate AO with linear fog
						"uniform bool onlyAO;",      // use only ambient occlusion pass?
						"uniform vec2 size;",        // texture width, height
						"uniform float aoClamp;",    // depth clamp - reduces haloing at screen edges
						"uniform float lumInfluence;",  // how much luminance affects occlusion
						"uniform sampler2D tDiffuse;",
						"uniform sampler2D tDepth;",
						"varying vec2 vUv;",

						// "#define PI 3.14159265",
						"#define DL 2.399963229728653",  // PI * ( 3.0 - sqrt( 5.0 ) )
						"#define EULER 2.718281828459045",

						// helpers
						"float width = size.x;",   // texture width
						"float height = size.y;",  // texture height
						"float cameraFarPlusNear = cameraFar + cameraNear;",
						"float cameraFarMinusNear = cameraFar - cameraNear;",
						"float cameraCoef = 2.0 * cameraNear;",

						// user variables
						"const int samples = 32;",     // ao sample count
						"const float radius = 10.0;",  // ao radius
						"const bool useNoise = true;",      // use noise instead of pattern for sample dithering
						"const float noiseAmount = 0.003;", // dithering amount
						"const float diffArea = 0.4;",   // self-shadowing reduction
						"const float gDisplace = 0.4;",  // gauss bell center
						"const vec3 onlyAOColor = vec3( 1.0, 0.7, 0.5 );",

						// RGBA depth
						"float unpackDepth( const in vec4 rgba_depth ) {",
							"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
							"float depth = dot( rgba_depth, bit_shift );",
							"return depth;",
						"}",

						// generating noise / pattern texture for dithering
						"vec2 rand( const vec2 coord ) {",
							"vec2 noise;",
							"if ( useNoise ) {",
								"float nx = dot ( coord, vec2( 12.9898, 78.233 ) );",
								"float ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 );",
								"noise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );",
							"} else {",
								"float ff = fract( 1.0 - coord.s * ( width / 2.0 ) );",
								"float gg = fract( coord.t * ( height / 2.0 ) );",
								"noise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg;",
							"}",
							"return ( noise * 2.0  - 1.0 ) * noiseAmount;",
						"}",

						"float doFog() {",
							"float zdepth = unpackDepth( texture2D( tDepth, vUv ) );",
							"float depth = -cameraFar * cameraNear / ( zdepth * cameraFarMinusNear - cameraFar );",
							"return smoothstep( fogNear, fogFar, depth );",
						"}",

						"float readDepth( const in vec2 coord ) {",
							// "return ( 2.0 * cameraNear ) / ( cameraFar + cameraNear - unpackDepth( texture2D( tDepth, coord ) ) * ( cameraFar - cameraNear ) );",
							"return cameraCoef / ( cameraFarPlusNear - unpackDepth( texture2D( tDepth, coord ) ) * cameraFarMinusNear );",
						"}",

						"float compareDepths( const in float depth1, const in float depth2, inout int far ) {",
							"float garea = 2.0;",                         // gauss bell width
							"float diff = ( depth1 - depth2 ) * 100.0;",  // depth difference (0-100)

							// reduce left bell width to avoid self-shadowing
							"if ( diff < gDisplace ) {",
								"garea = diffArea;",
							"} else {",
								"far = 1;",
							"}",

							"float dd = diff - gDisplace;",
							"float gauss = pow( EULER, -2.0 * dd * dd / ( garea * garea ) );",
							"return gauss;",
						"}",

						"float calcAO( float depth, float dw, float dh ) {",
							"float dd = radius - depth * radius;",
							"vec2 vv = vec2( dw, dh );",

							"vec2 coord1 = vUv + dd * vv;",
							"vec2 coord2 = vUv - dd * vv;",

							"float temp1 = 0.0;",
							"float temp2 = 0.0;",

							"int far = 0;",
							"temp1 = compareDepths( depth, readDepth( coord1 ), far );",

							// DEPTH EXTRAPOLATION
							"if ( far > 0 ) {",
								"temp2 = compareDepths( readDepth( coord2 ), depth, far );",
								"temp1 += ( 1.0 - temp1 ) * temp2;",
							"}",

							"return temp1;",
						"}",

						"void main() {",
							"vec2 noise = rand( vUv );",
							"float depth = readDepth( vUv );",

							"float tt = clamp( depth, aoClamp, 1.0 );",

							"float w = ( 1.0 / width )  / tt + ( noise.x * ( 1.0 - noise.x ) );",
							"float h = ( 1.0 / height ) / tt + ( noise.y * ( 1.0 - noise.y ) );",

							"float pw;",
							"float ph;",

							"float ao;",

							"float dz = 1.0 / float( samples );",
							"float z = 1.0 - dz / 2.0;",
							"float l = 0.0;",

							"for ( int i = 0; i <= samples; i ++ ) {",
								"float r = sqrt( 1.0 - z );",

								"pw = cos( l ) * r;",
								"ph = sin( l ) * r;",
								"ao += calcAO( depth, pw * w, ph * h );",
								"z = z - dz;",
								"l = l + DL;",
							"}",

							"ao /= float( samples );",
							"ao = 1.0 - ao;",

							"if ( fogEnabled ) {",
								"ao = mix( ao, 1.0, doFog() );",
							"}",

							"vec3 color = texture2D( tDiffuse, vUv ).rgb;",

							"vec3 lumcoeff = vec3( 0.299, 0.587, 0.114 );",
							"float lum = dot( color.rgb, lumcoeff );",
							"vec3 luminance = vec3( lum );",

							"vec3 final = vec3( color * mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );",  // mix( color * ao, white, luminance )

							"if ( onlyAO ) {",
								"final = onlyAOColor * vec3( mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );",  // ambient occlusion only
							"}",

							"gl_FragColor = vec4( final, 1.0 );",
						"}"
					].join("\n")
				};
			
				var depthShader = THREE.ShaderLib[ "depthRGBA" ];
				var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );
				depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );
				depthMaterial.blending = THREE.NoBlending;
				
				composer = new THREE.EffectComposer( renderer );
				composer.addPass( new THREE.RenderPass( scene, camera ) );

				depthTarget = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat } );
				
				var effect = new THREE.ShaderPass( THREE.SSAOShader );
				effect.uniforms[ 'tDepth' ].value = depthTarget;
				effect.uniforms[ 'size' ].value.set( window.innerWidth, window.innerHeight );
				effect.uniforms[ 'cameraNear' ].value = camera.near;
				effect.uniforms[ 'cameraFar' ].value = camera.far;
				effect.uniforms[ 'aoClamp' ].value = 5.0;
				effect.uniforms[ 'lumInfluence' ].value = 1.0;
				//effect.uniforms[ 'fogEnabled' ].value = 1;
				//effect.uniforms[ 'onlyAO' ].value = 1.0;
				effect.renderToScreen = true;
				composer.addPass( effect );
			};
			function initSkyBox() {
				var skyBoxFaces = [
					'textures/skyBox/px.jpg', 
					'textures/skyBox/nx.jpg',
					'textures/skyBox/py.jpg',
					'textures/skyBox/ny.jpg',
					'textures/skyBox/pz.jpg',
					'textures/skyBox/nz.jpg'
				];
				var textureCube = THREE.ImageUtils.loadTextureCube( skyBoxFaces, new THREE.CubeRefractionMapping() );
				var shader = THREE.ShaderLib[ "cube" ];
				shader.uniforms[ "tCube" ].value = textureCube;
				var skyBoxMaterial = new THREE.ShaderMaterial( {
					fragmentShader: shader.fragmentShader,
					vertexShader: shader.vertexShader,
					uniforms: shader.uniforms,
					side: THREE.BackSide
				} );
				
				var skyBoxGeometry = new THREE.CubeGeometry( 10000, 10000, 10000 );
				var skyBoxMesh = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
				scene.add(skyBoxMesh);
			};
			function loadGeometry() {
				var loader = new THREE.OBJLoader( );
				loader.load( 'models/FirelinkShrine/FirelinkShrine.obj', function ( object ) {
					object.scale.set( 10, 10, 10 );
					collisionMesh = object;
					collisionMesh.scale = new THREE.Vector3( 10, 10, 10 );
					
						collisionMesh.castShadow = true;
						collisionMesh.receiveShadow = true;
						
						// set the mesh to cast/receive shadows
						collisionMesh.children[0].children[0].castShadow = true;
						collisionMesh.children[0].children[0].receiveShadow = true;
					
					scene.add( object );
					sceneGraph.add( collisionMesh.children[0].children[0], { useFaces: true } );
					kbamControls.sceneGraph = sceneGraph;
					document.getElementById( "loadingScreen" ).style.display = "none";
				} );
			};
			function initControls() {
				oculusControls = new NUMIDIUM.OculusControls( camera );
				kbamControls = new NUMIDIUM.NumidiumControls( camera );				
				kbamControls.getObject().position.set( 591, -150, -524 );
				scene.add( kbamControls.getObject() );
				pointerLockAttach();
			};
			function init() {
				initScene();
				initCamera();
				initRenderer();
				initPostProcessing();
				initSkyBox();
				loadGeometry();
				initControls();
			};

			function animate() {
				requestAnimationFrame( animate );
				
				stats.update();
				sceneGraph.update();
				kbamControls.update( Date.now() - time );
				oculusControls.update( clock.getDelta(), kbamControls.getGamepadRotate() );
				
				if ( isAnaglyph ) {
					renderer.autoClear = false;
					anaglyphRenderer.render( scene, camera );
				}
				else if (isOculus) {
					renderer.autoClear = false;
					oculusRenderer.render( scene, camera );
				}
				else {
					renderer.autoClear = true;
					scene.overrideMaterial = depthMaterial;
					renderer.render( scene, camera, depthTarget );

					scene.overrideMaterial = null;
					composer.render();		
				}
				
				time = Date.now();				
			};
			
			function onWindowResize () {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
				anaglyphRenderer.setSize( window.innerWidth, window.innerHeight );
				oculusRenderer.setSize( window.innerWidth, window.innerHeight );
				
				depthRenderTarget = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat } );

				ssaoEffectPass.uniforms[ 'size' ].value.set( window.innerWidth, window.innerHeight );
				ssaoEffectPass.uniforms[ 'tDepth' ].texture = depthRenderTarget;
				
			};
			
			function onKeyDown ( event ) {
				console.log( event.keyCode );
				switch ( event.keyCode ) {
					//case 49:	//1
						//ssaoEffectPass.enabled = !ssaoEffectPass.enabled;	//TODO: on/off switch for SSAO
						//break;
					case 73:	//i
						isAnaglyph = true;
						isOculus = false;
						oculusControls.freeze = true;
						onWindowResize();
						break;
					case 79:	//o
						isAnaglyph = false;
						isOculus = true;
						oculusControls.connect();	// send a GET to http://localhost:50000/
						oculusControls.freeze = false;
						onWindowResize();
						break;
					case 80:	//p
						isAnaglyph = false;
						isOculus = false;
						oculusControls.freeze = true;
						onWindowResize();
						break;
				}
			};

		</script>
	</body>
</html>